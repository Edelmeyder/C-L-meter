/* Main.c file generated by New Project wizard
 *
 * Created:   lun. nov. 1 2021
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */

#include <stm32f103x6.h>
#include <stdint.h>
#include "lcd.h"

#define PI 3.141592654F

void delay_uss(uint16_t);

volatile uint32_t t0, t;
volatile float Pe, F, L;

int main (void){
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;	// enable PORT A clock
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // enable timer 2 clock
	GPIOA->CRL = (GPIOA->CRL & 0xF3FFF8FF) | 0x03000800; // PA2 (TIM2 CH3): input pull-up/down
	GPIOA->BRR = (1<<6);
	GPIOA->ODR |= (1<<2); // Pull-up
	TIM2->CCMR2 = 0x0001;  // Pin TIM2_CH3 as input for channel 3 - prescaler 1 - filter 1
	TIM2->CCER = (1<<8); // CC3P = 0 (rising edge), CC3E = 1 enable
	TIM2->PSC = 7200-1; // prescaller 7200 - 72MHz/7200 = 10kHz
	TIM2->ARR = 50000-1;
	TIM2->CR1 = 1; // start counting up
	t0 = 0;
	t = 0;
	while(1) {
		GPIOA->BSRR = (1<<6);
		while((TIM2->SR &(1<<3)) == 0); // wait until the CC3IF flag sets
		t = TIM2->CCR3; // read the captured value
		Pe = (t - t0) / 10000.0; // contador sobre frecuencia de contador
		F = 1 / Pe; // frecuencia = 1 / periodo
		L = 1 / ((2*PI*F) * (2*PI*F) * 0.000010); // L = 1/F^2*C
		t0 = t;
		GPIOA->BRR = (1<<6);
	}
}


// Medidor RC
/*
const uint16_t v632 = 2607;

volatile uint32_t v, time;
volatile float C;

int main (void){ 
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;	// enable PORT A clock
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;	// enable ADC1 clock
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // enable timer 2 clock
	GPIOA->CRL = (GPIOA->CRL & 0xFF3FFF0F) | 0x00300000; // PA1 analog input, PA5 GP output
	GPIOA->BRR = (1<<5);
	delay_uss(10000);
	ADC1->CR2 = 1; // ADC1 on
	ADC1->SMPR2 = (1<<3); // SMPR2->SMP1 = 001 => Sample time Ch1 7.5 adc cycles
	TIM2->ARR = 49999;
	LCD_init();
	LCD_goToXY(0,0);
	LCD_sendString((uint8_t*) "C: ", 3);
	LCD_goToXY(0,1);
	LCD_sendString((uint8_t*) "L: ", 3);
	while (1){
		v = 0;
		TIM2->CNT = 0; // Reset counter
		GPIOA->BSRR = (1<<5); // Raise PA8
		TIM2->CR1 = 1; // Start counting
		while(v < 2607) {
			ADC1->SQR3 = 1; // Channel 1
			ADC1->CR2 |= 1; // Start conversion
			while((ADC1->SR) & (1<<1) == 0); // wait for EOC
			v = ADC1->DR;
		}
		time = TIM2->CNT; 
		TIM2->CR1 = 0; // Stop timer counter
		LCD_goToXY(3,0);
		C = time/ 72000000.0;
		C = C/10000;
		GPIOA->BRR = (1<<5);
		delay_uss(350);
	}
}
*/
void delay_uss(uint16_t t) {
	uint16_t l, i;
	for(i = 0; i < t; i++)
		for(l = 0; l < 12; l++){}
}
